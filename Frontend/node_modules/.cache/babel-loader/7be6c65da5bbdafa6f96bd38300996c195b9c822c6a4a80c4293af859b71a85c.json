{"ast":null,"code":"var _jsxFileName = \"/Users/yushanlu/Desktop/Othello/othello-test/src/Canvas-test.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction CanvasComponent() {\n  _s();\n  const canvasRef = useRef(null);\n  canvas.addEventListener(\"click\", function (event) {\n    // This code calculates the location of the canvas, because mouse clicks are not automatically relative to the canvas\n    var boundingRect = event.target.getBoundingClientRect();\n    var elemLeft = boundingRect.left;\n    var elemTop = boundingRect.top;\n    var x = event.clientX - elemLeft,\n      y = event.clientY - elemTop;\n    if (started == 0) return;\n\n    // Convert the (x, y) coords to a box on the grid\n    var targetX = Math.floor(x / gridsize);\n    var targetY = Math.floor(y / gridsize);\n    console.log(`Targeting ${targetX} ${targetY}`);\n    if (board[targetX][targetY] != \"\") return;\n\n    // Place a piece!\n    // TODO: send placement over WS and render the updated board state\n    board[targetX][targetY] = turn;\n    turn = turn == \"W\" ? \"B\" : \"W\";\n    turn == \"W\" ? whiteCount++ : blackCount++;\n  });\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const context = canvas.getContext('2d');\n\n    // Draw a red rectangle\n    var cw = canvas.width;\n    var ch = canvas.height;\n    var b = 2; // Padding between cells\n    var gridsize = 75;\n    var fps = 50;\n    var board = [];\n    var whiteCount = 0;\n    var blackCount = 0;\n    function init() {\n      paused = 0;\n      board = [];\n      for (let i = 0; i < 8; i++) {\n        board[i] = [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"];\n      }\n      board[3][3] = \"W\";\n      board[4][3] = \"B\";\n      board[4][4] = \"W\";\n      board[3][4] = \"B\";\n      whiteCount = 2;\n      blackCount = 2;\n    }\n    init();\n    setInterval(draw, 1000 / fps);\n\n    /* **************** */\n    /*      DRAW        */\n    /* **************** */\n\n    // This runs every frame and handles all rendering drawing operations.\n    function draw() {\n      // Without this, previous frames remain on the screen\n      ctx.clearRect(0, 0, cw, ch);\n\n      // Background\n      ctx.fillStyle = \"green\";\n      ctx.fillRect(0, 0, cw, ch);\n      ctx.fillStyle = \"black\";\n\n      // Draw the lines\n      for (var d1 = 0; d1 < 602; d1 += gridsize) {\n        ctx.fillRect(d1, 0, b, ch);\n        ctx.fillRect(0, d1, cw, b);\n      }\n\n      // Draw the 4 weird little circles around the middle 4 squares:\n      ctx.beginPath();\n      ctx.arc(150 + b / 2, 150 + b / 2, 3 * b, 0, 3 * Math.PI);\n      ctx.fill();\n      ctx.closePath();\n      ctx.beginPath();\n      ctx.arc(150 + b / 2, 452 - b / 2, 3 * b, 0, 3 * Math.PI);\n      ctx.fill();\n      ctx.closePath();\n      ctx.beginPath();\n      ctx.arc(452 - b / 2, 150 + b / 2, 3 * b, 0, 3 * Math.PI);\n      ctx.fill();\n      ctx.closePath();\n      ctx.beginPath();\n      ctx.arc(452 - b / 2, 452 - b / 2, 3 * b, 0, 3 * Math.PI);\n      ctx.fill();\n      ctx.closePath();\n\n      // Change the content of the piece-counters\n      numWhiteElement.textContent = \"white:  \" + whiteCount;\n      numBlackElement.textContent = \"black:  \" + blackCount;\n\n      // Draw the pieces\n      for (let x = 0; x < 8; x++) {\n        for (let y = 0; y < 8; y++) {\n          if (board[x][y] == \"W\") {\n            ctx.beginPath();\n            ctx.arc(\n            // define the circle\n            x * gridsize + gridsize / 2, y * gridsize + gridsize / 2, gridsize / 2 - 4 * b,\n            // radius\n            0,\n            // startAngle\n            2 * Math.PI // endAngle\n            );\n\n            ctx.fillStyle = \"white\";\n            ctx.fill();\n            ctx.closePath();\n          } else if (board[x][y] == \"B\") {\n            ctx.beginPath();\n            ctx.arc(x * gridsize + gridsize / 2, y * gridsize + gridsize / 2, gridsize / 2 - 4 * b, 0, 2 * Math.PI);\n            ctx.fillStyle = \"black\";\n            ctx.fill();\n            ctx.closePath();\n          }\n        }\n      }\n    }\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    ref: canvasRef,\n    width: 200,\n    height: 200\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 149,\n    columnNumber: 10\n  }, this);\n}\n_s(CanvasComponent, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = CanvasComponent;\nexport default CanvasComponent;\nvar _c;\n$RefreshReg$(_c, \"CanvasComponent\");","map":{"version":3,"names":["React","useRef","useEffect","jsxDEV","_jsxDEV","CanvasComponent","_s","canvasRef","canvas","addEventListener","event","boundingRect","target","getBoundingClientRect","elemLeft","left","elemTop","top","x","clientX","y","clientY","started","targetX","Math","floor","gridsize","targetY","console","log","board","turn","whiteCount","blackCount","current","context","getContext","cw","width","ch","height","b","fps","init","paused","i","setInterval","draw","ctx","clearRect","fillStyle","fillRect","d1","beginPath","arc","PI","fill","closePath","numWhiteElement","textContent","numBlackElement","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/yushanlu/Desktop/Othello/othello-test/src/Canvas-test.js"],"sourcesContent":["import React, { useRef, useEffect } from 'react';\n\nfunction CanvasComponent() {\n  const canvasRef = useRef(null);\n\n  \n\ncanvas.addEventListener(\"click\", function (event) {\n\t// This code calculates the location of the canvas, because mouse clicks are not automatically relative to the canvas\n\tvar boundingRect = event.target.getBoundingClientRect();\n\tvar elemLeft = boundingRect.left;\n\tvar elemTop = boundingRect.top;\n\tvar x = event.clientX - elemLeft,\n\t\ty = event.clientY - elemTop;\n\n\tif (started == 0) return;\n\n\t// Convert the (x, y) coords to a box on the grid\n\tvar targetX = Math.floor(x / gridsize);\n\tvar targetY = Math.floor(y / gridsize);\n\tconsole.log(`Targeting ${targetX} ${targetY}`);\n\n\tif (board[targetX][targetY] != \"\") return;\n\n\t// Place a piece!\n\t// TODO: send placement over WS and render the updated board state\n\tboard[targetX][targetY] = turn;\n\tturn = turn == \"W\" ? \"B\" : \"W\";\n\n\tturn == \"W\" ? whiteCount++ : blackCount++;\n});\n\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const context = canvas.getContext('2d');\n\n    // Draw a red rectangle\n    var cw = canvas.width;\nvar ch = canvas.height;\nvar b = 2; // Padding between cells\nvar gridsize = 75;\nvar fps = 50;\n\nvar board = [];\nvar whiteCount = 0;\nvar blackCount = 0;\n\nfunction init() {\n\tpaused = 0;\n\tboard = [];\n\n\tfor (let i = 0; i < 8; i++) {\n\t\tboard[i] = [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"];\n\t}\n\n\tboard[3][3] = \"W\";\n\tboard[4][3] = \"B\";\n\tboard[4][4] = \"W\";\n\tboard[3][4] = \"B\";\n\n\twhiteCount = 2;\n\tblackCount = 2;\n}\n\ninit();\nsetInterval(draw, 1000 / fps);\n\n\n/* **************** */\n/*      DRAW        */\n/* **************** */\n\n// This runs every frame and handles all rendering drawing operations.\nfunction draw() {\n\t// Without this, previous frames remain on the screen\n\tctx.clearRect(0, 0, cw, ch);\n\n\t// Background\n\tctx.fillStyle = \"green\";\n\tctx.fillRect(0, 0, cw, ch);\n\n\tctx.fillStyle = \"black\";\n\n\t// Draw the lines\n\tfor (var d1 = 0; d1 < 602; d1 += gridsize) {\n\t\tctx.fillRect(d1, 0, b, ch);\n\t\tctx.fillRect(0, d1, cw, b);\n\t}\n\n\t// Draw the 4 weird little circles around the middle 4 squares:\n\tctx.beginPath();\n\tctx.arc(150 + b / 2, 150 + b / 2, 3 * b, 0, 3 * Math.PI);\n\tctx.fill();\n\tctx.closePath();\n\n\tctx.beginPath();\n\tctx.arc(150 + b / 2, 452 - b / 2, 3 * b, 0, 3 * Math.PI);\n\tctx.fill();\n\tctx.closePath();\n\tctx.beginPath();\n\n\tctx.arc(452 - b / 2, 150 + b / 2, 3 * b, 0, 3 * Math.PI);\n\tctx.fill();\n\tctx.closePath();\n\n\tctx.beginPath();\n\tctx.arc(452 - b / 2, 452 - b / 2, 3 * b, 0, 3 * Math.PI);\n\tctx.fill();\n\tctx.closePath();\n\n\t// Change the content of the piece-counters\n\tnumWhiteElement.textContent = \"white:  \" + whiteCount;\n\tnumBlackElement.textContent = \"black:  \" + blackCount;\n\n\t// Draw the pieces\n\tfor (let x = 0; x < 8; x++) {\n\t\tfor (let y = 0; y < 8; y++) {\n\t\t\tif (board[x][y] == \"W\") {\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.arc( // define the circle\n\t\t\t\t\tx * gridsize + gridsize / 2,\n\t\t\t\t\ty * gridsize + gridsize / 2,\n\t\t\t\t\tgridsize / 2 - 4 * b, // radius\n\t\t\t\t\t0, // startAngle\n\t\t\t\t\t2 * Math.PI // endAngle\n\t\t\t\t);\n\t\t\t\tctx.fillStyle = \"white\";\n\t\t\t\tctx.fill();\n\t\t\t\tctx.closePath();\n\t\t\t} else if (board[x][y] == \"B\") {\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.arc(\n\t\t\t\t\tx * gridsize + gridsize / 2,\n\t\t\t\t\ty * gridsize + gridsize / 2,\n\t\t\t\t\tgridsize / 2 - 4 * b,\n\t\t\t\t\t0,\n\t\t\t\t\t2 * Math.PI\n\t\t\t\t);\n\t\t\t\tctx.fillStyle = \"black\";\n\t\t\t\tctx.fill();\n\t\t\t\tctx.closePath();\n\t\t\t}\n\t\t}\n\t}\n}\n  }, []);\n\n  return <canvas ref={canvasRef} width={200} height={200} />;\n}\n\nexport default CanvasComponent;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}